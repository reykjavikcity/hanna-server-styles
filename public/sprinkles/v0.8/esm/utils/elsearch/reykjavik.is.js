const i=(t,e,r)=>{const s=e.map(function(a,n){return""+a+(Array.isArray(r.fieldWeights)&&r.fieldWeights[n]?"^"+r.fieldWeights[n]:"")});return r.searchOperators?{query:t,fields:s,default_operator:r.queryFormat}:r.queryFormat==="and"?[{multi_match:{query:t,fields:s,type:"bool_prefix",operator:"and"}},{multi_match:{query:t,fields:s,type:"phrase",operator:"and"}}]:[{multi_match:{query:t,fields:s,type:"best_fields",operator:"or",fuzziness:r.fuzziness?r.fuzziness:0}},{multi_match:{query:t,fields:s,type:"phrase",operator:"or"}}]},d=(t,e)=>{let r=null,s=[];if(t&&t!=="")if(Array.isArray(e.dataField)?s=e.dataField:s=[e.dataField],e.searchOperators)r={simple_query_string:i(t,s,e)};else{const a=e.filter||void 0;r={bool:{should:i(t,s,e),minimum_should_match:"1",filter:a}},e.exceptBundles&&e.exceptBundles.length&&(r.bool.must_not={terms:{bundle:e.exceptBundles}})}return r&&e.nestedField&&(r={nested:{path:e.nestedField,query:r}}),r},p=(t,e)=>{var r;return e&&((r=e.find(s=>s.key===t))==null?void 0:r.doc_count)||0},o=t=>{const{value:e,preference:r,aggs:s,size:a,from:n,_source:l,filter:u,exceptBundles:f}=t;return{preference:r,query:{...d(e,{fuzziness:"AUTO",fieldWeights:[10,2,1],dataField:["label","field_preview_text.value","content"],queryFormat:"and",filter:u,exceptBundles:f})},aggs:s,size:a,from:n,sort:[{_score:{order:"desc"}},{bundle_weight:{order:"desc"}}],_source:l}},y=["label","field_summary","url_alias","url_internal","rendered_search_result"],m={bundle:{terms:{field:"bundle",order:{_count:"desc"}}}},_=t=>{const{value:e,preference:r="resultspage",size:s,aggs:a=m,from:n,_source:l=y,filter:u}=t;return[o({value:e,preference:r,aggs:a,_source:!1}),o({value:e,preference:r,size:s,from:n,_source:l,filter:u})]},c=t=>{const{preference:e,...r}=t;return`{ "preference": "${e}" }
`+JSON.stringify({...r})+`
`},h=t=>{var e,r;const s=(r=(e=t.aggregations)==null?void 0:e.bundle)==null?void 0:r.buckets.reduce((a,{key:n,doc_count:l})=>(a[n]=l,a),{});return{totalHits:t.hits.total.value,items:t.hits.hits.map(({_source:a})=>a),aggregateData:s}},g=(t,e,r)=>(e=Array.isArray(e)?e:[e],fetch(t,{headers:{Accept:"application/json","Content-Type":"application/x-ndjson"},signal:r,method:"POST",body:e.map(c).join("")}).then(async s=>{const a=await s.json();return a.responses&&a.responses.map(n=>h(n))||[]}));export{o as createElasticQuery,d as defaultQuery,p as getBundleCount,g as postQuery,c as queryToString,_ as searchResultsPageQuery,i as shouldQuery};
